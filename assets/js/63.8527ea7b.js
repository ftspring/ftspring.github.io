(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{652:function(a,e,t){"use strict";t.r(e);var r=t(15),s=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h4",{attrs:{id:"增加开发体验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增加开发体验"}},[a._v("#")]),a._v(" 增加开发体验")]),a._v(" "),t("h5",{attrs:{id:"sourcemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sourcemap"}},[a._v("#")]),a._v(" SourceMap")]),a._v(" "),t("p",[a._v("用于代码出错时，快速定位到自己代码的位置。下面主要介绍两种常用的，有兴趣可以自行官网查看 "),t("a",{attrs:{href:"https://webpack.docschina.org/configuration/devtool/",target:"_blank",rel:"noopener noreferrer"}},[a._v("官方文档"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("开发中主要用到的两种模式是：")]),a._v(" "),t("ol",[t("li",[t("p",[t("strong",[a._v("cheap-module-source-map")]),a._v("：主要用于开发模式，只有行映射，没有列映射。但是打包速度快，而且开发模式下，没有进行代码压缩，所以够用了。")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("eval-cheap-module-source-map")]),a._v(" ： 主要用于生产模式，包含行列映射，但是打包速度会较慢。生产模式代码进行压缩，只有一行，所以必须要列映射。")])])]),a._v(" "),t("h4",{attrs:{id:"打包构建速度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包构建速度"}},[a._v("#")]),a._v(" 打包构建速度")]),a._v(" "),t("h5",{attrs:{id:"hotmodulereplacement"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hotmodulereplacement"}},[a._v("#")]),a._v(" HotModuleReplacement")]),a._v(" "),t("p",[a._v("哪个模块被修改，只需要重新打包编译那个模块就行了。其他模块无需发生变化。")]),a._v(" "),t("div",{staticClass:"language-javascript line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("hot")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 开启HMR功能（只能用于开发环境，生产环境不需要了）")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h5",{attrs:{id:"oneof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#oneof"}},[a._v("#")]),a._v(" OneOf")]),a._v(" "),t("p",[a._v("每个文件只会被 loader 中的一个 loader 配置处理")]),a._v(" "),t("p",[a._v("用法：直接使用 oneOf 包裹住所有的 loader 配置")]),a._v(" "),t("h5",{attrs:{id:"include-exclude"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#include-exclude"}},[a._v("#")]),a._v(" Include/Exclude")]),a._v(" "),t("p",[a._v("对 js 文件处理时，不需要对 node"),t("em",[a._v("modules 下的文件进行处理。所以需要排除掉 node")]),a._v(" modules 下的文件。")]),a._v(" "),t("ol",[t("li",[t("p",[t("strong",[a._v("include")]),a._v("：只处理 xxx 文件")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("exclude")]),a._v(" ： 除 xxx 文件外，其他文件都处理")])])]),a._v(" "),t("h5",{attrs:{id:"cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache"}},[a._v("#")]),a._v(" Cache")]),a._v(" "),t("p",[a._v("用于缓存之前的 Eslint 检查 和 Babel 编译结果。这样下次打包就可以直接引用，速度较快。")]),a._v(" "),t("h5",{attrs:{id:"thead"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#thead"}},[a._v("#")]),a._v(" Thead")]),a._v(" "),t("p",[a._v("多进程同时处理 js 文件。同时使用 eslint、babel、terset 三个工具对 js 进行处理。但是有较大开销。")]),a._v(" "),t("h4",{attrs:{id:"减少代码体积"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#减少代码体积"}},[a._v("#")]),a._v(" 减少代码体积")]),a._v(" "),t("h5",{attrs:{id:"tree-shaking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking"}},[a._v("#")]),a._v(" Tree Shaking")]),a._v(" "),t("p",[a._v("引入库的时候，移除 js 中 没有使用到的代码。也就是按需引入。 webpack 默认开启这个功能了。")]),a._v(" "),t("h5",{attrs:{id:"babel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[a._v("#")]),a._v(" Babel")]),a._v(" "),t("p",[a._v("将 babel 为每个文件插入的辅助代码放到一个独立模块，让需要的地方自己来引入。避免重复引入。")]),a._v(" "),t("h5",{attrs:{id:"image-minimizer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#image-minimizer"}},[a._v("#")]),a._v(" image Minimizer")]),a._v(" "),t("p",[a._v("对图片进行压缩（本地项目中静态图片才需要进行压缩）")]),a._v(" "),t("h4",{attrs:{id:"代码运行性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码运行性能"}},[a._v("#")]),a._v(" 代码运行性能")]),a._v(" "),t("h5",{attrs:{id:"code-split"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#code-split"}},[a._v("#")]),a._v(" Code Split")]),a._v(" "),t("p",[a._v("将打包生成的文件进行分割，生成多个 js 文件。然后进行按需加载。")]),a._v(" "),t("h5",{attrs:{id:"preload-prefetch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#preload-prefetch"}},[a._v("#")]),a._v(" Preload / Prefetch")]),a._v(" "),t("p",[a._v("在空闲时间能自动加载后续所需的资源。兼容性都比较差。")]),a._v(" "),t("ol",[t("li",[t("p",[t("strong",[a._v("Preload")]),a._v(" ： 告诉浏览器马上加载资源，加载优先级高，只能加载当前页面所需的资源。")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("Prefetch")]),a._v(" ：告诉浏览器在空闲时间加载资源，加载优先级低，可以加载当前页面资源，也可加载下一个页面所需的资源。")])])]),a._v(" "),t("h5",{attrs:{id:"network-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#network-cache"}},[a._v("#")]),a._v(" Network Cache")]),a._v(" "),t("p",[a._v("对静态资源进行缓存，二次请求时就可以直接走缓存，速度比较快。使用不同的 hash 值作为更新前后的文件名，就可以区分缓存了。")]),a._v(" "),t("p",[a._v("1."),t("strong",[a._v("fullhash")]),a._v("（webpack4 是 hash）")]),a._v(" "),t("p",[a._v("每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。")]),a._v(" "),t("p",[a._v("2."),t("strong",[a._v("chunkhash")])]),a._v(" "),t("p",[a._v("根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。")]),a._v(" "),t("p",[a._v("3."),t("strong",[a._v("contenthash")])]),a._v(" "),t("p",[a._v("根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。")]),a._v(" "),t("h5",{attrs:{id:"core-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#core-js"}},[a._v("#")]),a._v(" Core-js")]),a._v(" "),t("p",[a._v("babel 只能对 ES6 部分语法进行编译，如箭头函数、rest 等等。其他的没办法处理。剩下的就使用 Core-js 进行处理。")]),a._v(" "),t("h5",{attrs:{id:"pwa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pwa"}},[a._v("#")]),a._v(" PWA")]),a._v(" "),t("p",[a._v("给项目提供离线体验")]),a._v(" "),t("p",[t("a",{attrs:{href:"http://192.168.252.1:8080/webpack5-docs/senior/",target:"_blank",rel:"noopener noreferrer"}},[a._v("学习地址"),t("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);