(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{653:function(_,t,v){"use strict";v.r(t);var r=v(15),s=Object(r.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h4",{attrs:{id:"_1-用户在浏览器中输入-url-浏览器接收到-url。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-用户在浏览器中输入-url-浏览器接收到-url。"}},[_._v("#")]),_._v(" 1.  用户在浏览器中输入 url，浏览器接收到 url。")]),_._v(" "),v("h4",{attrs:{id:"_2-浏览器接收到这个-url-之后-会根据这个-url-会先查看缓存-如果有缓存且没有过期的话直接提供给客户端-完成页面渲染。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器接收到这个-url-之后-会根据这个-url-会先查看缓存-如果有缓存且没有过期的话直接提供给客户端-完成页面渲染。"}},[_._v("#")]),_._v(" 2.浏览器接收到这个 url 之后，会根据这个 url 会先查看缓存，如果有缓存且没有过期的话直接提供给客户端，完成页面渲染。")]),_._v(" "),v("h4",{attrs:{id:"_3-否则浏览器就会通过-dns-解析-url-获得协议名、主机名、端口号。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-否则浏览器就会通过-dns-解析-url-获得协议名、主机名、端口号。"}},[_._v("#")]),_._v(" 3.否则浏览器就会通过 DNS 解析 url ，获得协议名、主机名、端口号。")]),_._v(" "),v("p",[v("strong",[_._v("DNS 解析")]),_._v("详解：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("输入域名时，操作系统会先检查自己"),v("strong",[_._v("本地 host 文件")]),_._v("中是否有这个网址的映射关系，如果有，就调用这个 IP 地址映射，完成域名解析。")])]),_._v(" "),v("li",[v("p",[_._v("如果 host 没有这个域名的映射，则查找"),v("strong",[_._v("本地的 DNS 解析器缓存")]),_._v("，是否有这个网址映射关系，如果有，直接返回，完成域名解析。")])]),_._v(" "),v("li",[v("p",[_._v("如果本地解析器缓存没有的话，则查找"),v("strong",[_._v("本地 DNS 服务器")]),_._v("，如果要查询的域名包含在本地配置资源中，则完成域名解析。")])]),_._v(" "),v("li",[v("p",[_._v("如果本地 DNS 服务器没有的话，就会请求"),v("strong",[_._v("根服务器")]),_._v("，根服务器就会返回一个负责该区域的"),v("strong",[_._v("主服务器 IP")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("本地域名服务器")]),_._v("根据"),v("strong",[_._v("主服务器 IP")]),_._v("，链接到这个"),v("strong",[_._v("主域名服务器")]),_._v("，如果有这个域名的话，就调用这个 IP 地址映射，完成域名解析。如果没有的话，则递归请求下一级域名服务器，直到找到对应的域名")])])]),_._v(" "),v("h3",{attrs:{id:"_4-然后浏览器就会根据这个-ip-跟对应的服务端建立-tcp-连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-然后浏览器就会根据这个-ip-跟对应的服务端建立-tcp-连接"}},[_._v("#")]),_._v(" 4.然后浏览器就会根据这个 IP 跟对应的服务端建立 tcp 连接")]),_._v(" "),v("p",[v("strong",[_._v("TCP 三次握手")]),_._v("：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("第一次握手：客户端向服务器发送一个 SYN=1 报文，并指定客户端的初始化序列号 seq=x。此时客户端处于 SYN_Sent 状态")])]),_._v(" "),v("li",[v("p",[_._v("第二次握手：服务器接收到客户端的 SYN=1 报文后，同意连接的话，会发出一段确定报文。确定报文中应该 ACK= 1，SYN= 1，确认号是 ack=x+1,同时也要为自己初始化一个序列号 seq=y.此时服务器处于 SYN-RCVD")])]),_._v(" "),v("li",[v("p",[_._v("第三次握手：客户端接收到 SYN 报文之后，还会向服务器发送确定。确定报文的 ACK=1，ack=y+1 ,自己的序列号变成 x+1。TCP 连接建立，客户端处于 已连接状态 。")])])]),_._v(" "),v("h3",{attrs:{id:"_5-当服务器接受到客户端的确认后也进入了-已连接状态-。此时双方就可以开始通信了"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-当服务器接受到客户端的确认后也进入了-已连接状态-。此时双方就可以开始通信了"}},[_._v("#")]),_._v(" 5.当服务器接受到客户端的确认后也进入了 已连接状态 。此时双方就可以开始通信了")]),_._v(" "),v("h3",{attrs:{id:"_6-接下来就是浏览器向服务器发送-http-请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-接下来就是浏览器向服务器发送-http-请求"}},[_._v("#")]),_._v(" 6.接下来就是浏览器向服务器发送 HTTP 请求")]),_._v(" "),v("p",[_._v("TCP 连接建立之后，浏览器端会构建请求行、 请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。如果是  "),v("code",[_._v("HTTPS")]),_._v("，还需要进行  "),v("code",[_._v("TSL")]),_._v("  协商。服务器还会检查 "),v("strong",[_._v("HTTP")]),_._v(" 的请求头，看是否包含缓存信息。")]),_._v(" "),v("h3",{attrs:{id:"_7-服务器接受并解析这个请求然后发送一个数据包给浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-服务器接受并解析这个请求然后发送一个数据包给浏览器"}},[_._v("#")]),_._v(" 7.服务器接受并解析这个请求然后发送一个数据包给浏览器")]),_._v(" "),v("h3",{attrs:{id:"_8-关闭浏览器与服务器之间的连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-关闭浏览器与服务器之间的连接"}},[_._v("#")]),_._v(" 8.关闭浏览器与服务器之间的连接")]),_._v(" "),v("p",[v("strong",[_._v("TCP 四次挥手")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("第一次挥手：客户端向服务端发送一个 FIN 报文，报文中指定一个序列号。此时，客户端处于 FIN_WAIT-1 状态")]),_._v(" "),v("li",[_._v("第二次挥手：服务端收到客户端 发送的 FIN 报文后，会将客户端的序列号+1 作为 ACK 报文的序列号值发送给客户端，表明收到了客户端的报文。然后服务器就会处于 CLOSE-WAIT-1 状态")]),_._v(" "),v("li",[_._v("第三次挥手：服务端向客户端发送 FIN 报文，且指定一个序列号。此时，服务端处于 LAST_ACK 状态")]),_._v(" "),v("li",[_._v("第四次挥手：客户端收到服务端发送的 FIN 报文后，会将服务端的序列号+1 作为 ACK 报文的序列号值发送给服务端，此时客户端处于 TIME_WAIT 状态。需要等服务端确定收到自己的 ACK 报文后才会进入 CLOSED 状态")]),_._v(" "),v("li",[_._v("服务端接收到 ACK 报文后，就关闭连接，处于 CLOSED 状态。")])]),_._v(" "),v("h3",{attrs:{id:"_9-浏览器就会根据这个数据包解析-html-文档-构建-dom-树-构建-cssom-树-解析-js-脚本-下载资源"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-浏览器就会根据这个数据包解析-html-文档-构建-dom-树-构建-cssom-树-解析-js-脚本-下载资源"}},[_._v("#")]),_._v(" 9.浏览器就会根据这个数据包解析 HTML 文档，构建 DOM 树，构建 CSSOM 树，解析 js 脚本，下载资源")]),_._v(" "),v("p",[v("strong",[_._v("渲染的具体过程")]),_._v("：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("浏览器会通过 "),v("strong",[_._v("HTML Parser")]),_._v(" （HTML 解析器）根据深度遍历的原则，将 html 解析成 DOM tree （DOM 树）。")])]),_._v(" "),v("li",[v("p",[_._v("浏览器会通过 "),v("strong",[_._v("CSS Parser")]),_._v(" （CSS 解析器）将 CSS 解析成 CSS Rule Tree（CSSOM 树）。")])]),_._v(" "),v("li",[v("p",[_._v("浏览器会将 javascript 通过 DOM API 或者 CSSOM API 将 JS 代码进行解析并应用到布局中，且会呈现出响应式的结果。")])]),_._v(" "),v("li",[v("p",[_._v("根据 DOM 树 与 CSSOM 树构建出响应的 render Tree。")])]),_._v(" "),v("li",[v("p",[_._v("接下来就是进行重排（reflow）与重绘（repaint）。当页面中任意一个"),v("strong",[_._v("节点的几何尺寸")]),_._v("发生变化的时候，就会触发"),v("strong",[_._v("重排")]),_._v("，就会重新计算页面中所有的节点的位置。当页面中任意元素的样式属性发生变化时（几何尺寸不发生变化），就会发生重绘，重新绘画发生变化的元素。重排一定会触发重绘，而重绘不一定会有重排。")])]),_._v(" "),v("li",[v("p",[_._v("paint：绘制。遍历 render Tree，并调用硬件图形 API 来绘制每个节点到页面上。")])])]),_._v(" "),v("h3",{attrs:{id:"_10-最终就会显示出这个页面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-最终就会显示出这个页面"}},[_._v("#")]),_._v(" 10.最终就会显示出这个页面")])])}),[],!1,null,null,null);t.default=s.exports}}]);